      Module MathTools       
      use global_tdplas    
      use constants        
      use pedra_friends
      use readio_medium       

      implicit none
      save
      private
      public diag_mat,inv,do_pot_from_field,do_field_from_charges,    &
             do_dip_from_charges,do_dip_from_coeff,do_pot_from_coeff, &
             do_pot_from_dip,do_vts_from_dip,mdl,vprod,               &
             do_cpot_from_coeff,do_field_from_dip                      
      contains
!
!------------------------------------------------------------------------
!> Diagonalizes the matrix M using dsyevd, E=eigenvalues, M=eigenvectors
!------------------------------------------------------------------------
      subroutine diag_mat(M,E,Md)     
      integer(i4b), intent(in) :: Md
      real(dbl), intent(inout) :: M(Md)
      real(dbl), intent(out) :: E(Md)
      ! Local variables
      integer(i4b) :: info,lwork,liwork
      integer(i4b), allocatable :: iwork(:)
      real(dbl),allocatable :: work(:)
      character jobz,uplo
       jobz = 'V'
       uplo = 'U'
       lwork = 1+6*Md+2*Md*Md
       liwork = 3+5*Md
       allocate(work(lwork))
       allocate(iwork(liwork))
       iwork=0
       work=zero
       call dsyevd (jobz,uplo,Md,M,Md,E,work,lwork,iwork,liwork,info)
       deallocate(work,iwork)
      return
      end subroutine
!
!------------------------------------------------------------------------
!> Computes the modulus of a vector               
!------------------------------------------------------------------------
      function mdl(v) result(m)
        real(dbl), dimension(:), intent(in) :: v
        real(dbl) :: m  
        integer(i4b) :: i
        m=zero
        do i=1,size(v)
          m=m+v(i)*v(i)
        enddo
        m=sqrt(m)
      end function mdl
!
!------------------------------------------------------------------------
!> Computes the vector product between two vectors
!------------------------------------------------------------------------
      function vprod(a,b) result(v)
        real(dbl), dimension(3), intent(in)  :: a  
        real(dbl), dimension(3), intent(in)  :: b  
        real(dbl), dimension(3) :: v 
        v(1)=a(2)*b(3)-a(3)*b(2)
        v(2)=a(3)*b(1)-a(1)*b(3)
        v(3)=a(1)*b(2)-a(2)*b(1)
      end function vprod
!
!
!------------------------------------------------------------------------
!> Inverts matrix A using LU factorization        
!------------------------------------------------------------------------
      function inv(A) result(Ainv)
        real(dbl), dimension(:,:), intent(in) :: A
        real(dbl), dimension(size(A,1),size(A,2)) :: Ainv
      
        real(dbl), dimension(size(A,1)) :: work  ! work array for LAPACK
        integer(i4b), dimension(size(A,1)) :: ipiv   ! pivot indices
        integer(i4b) :: n, info
      
        ! External procedures defined in LAPACK
        external DGETRF
        external DGETRI
      
        ! Store A in Ainv to prevent it from being overwritten by LAPACK
        Ainv = A
        n = size(A,1)
      
        ! DGETRF computes an LU factorization of a general M-by-N matrix A
        ! using partial pivoting with row interchanges.
        call DGETRF(n, n, Ainv, n, ipiv, info)
      
        if (info /= 0) then
           stop 'Matrix is numerically singular!'
        end if
      
        ! DGETRI computes the inverse of a matrix using the LU factorization
        ! computed by DGETRF.
        call DGETRI(n, Ainv, n, ipiv, work, n, info)
      
        if (info /= 0) then
           stop 'Matrix inversion failed!'
        end if
      end function inv
!
!------------------------------------------------------------------------
!> Calculates the potential on the BEM surface generated by a field (fld)
!------------------------------------------------------------------------
      subroutine do_pot_from_field(fld,pot)
      ! Computes the potential on tesserae given a position-independent 
      !  external field  
       real(dbl), intent(in):: fld(3) 
       real(dbl), intent(out):: pot(nts_act) 
       integer(i4b) :: its  
        ! Field
        pot(:)=zero
        do its=1,nts_act
          pot(its)=pot(its)-fld(1)*cts_act(its)%x           
          pot(its)=pot(its)-fld(2)*cts_act(its)%y          
          pot(its)=pot(its)-fld(3)*cts_act(its)%z         
        enddo
       return
      end subroutine
!
!------------------------------------------------------------------------
!> Calculates field f on molecule's center of charge from BEM charges q
!------------------------------------------------------------------------
      subroutine do_field_from_charges(q,f)
       real(dbl),intent(inout):: f(3)  
       real(dbl),intent(in):: q(nts_act)  
       real(dbl):: diff(3)  
       real(dbl):: dist
       integer(i4b) :: its  
        f(:)=zero
        do its=1,nts_act
          diff(1)=(mol_cc(1)-cts_act(its)%x)
          diff(2)=(mol_cc(2)-cts_act(its)%y)
          diff(3)=(mol_cc(3)-cts_act(its)%z)
          dist=sqrt(dot_product(diff,diff))
          f(:)=f(:)+q(its)*diff(:)/(dist**3)
        enddo
       return
      end subroutine
!
!------------------------------------------------------------------------
!> Calculates (updates previous value) the dipole (mu) of BEM charges (q)
!------------------------------------------------------------------------
      subroutine do_dip_from_charges(q,mu,qtot)
       real(dbl),intent(inout):: mu(3)  
       real(dbl),intent(in):: q(nts_act)  
       real(dbl),intent(out):: qtot  
       integer(i4b) :: its  
       qtot=zero
       do its=1,nts_act
         mu(1)=mu(1)+q(its)*(cts_act(its)%x)
         mu(2)=mu(2)+q(its)*(cts_act(its)%y)
         mu(3)=mu(3)+q(its)*(cts_act(its)%z)
         qtot=qtot+q(its)
       enddo
      return
      end subroutine
!
!------------------------------------------------------------------------
!> Calculates dipole from CIS coefficients 
!------------------------------------------------------------------------
      subroutine do_dip_from_coeff(c,dip,nc)
       integer(i4b), intent(IN) :: nc  
       complex(cmp), intent(IN) :: c(nc)
       real(dbl), intent(OUT) :: dip(3)
       integer(i4b) :: its  
         dip(1)=dot_product(c,matmul(mut(1,:,:),c))
         dip(2)=dot_product(c,matmul(mut(2,:,:),c))
         dip(3)=dot_product(c,matmul(mut(3,:,:),c))
       return
      end subroutine
!
!------------------------------------------------------------------------
!> Calculates potential on BEM surface from CIS coefficients 
!------------------------------------------------------------------------
      subroutine do_pot_from_coeff(c,pot)
       complex(cmp), intent(IN) :: c(n_ci)
       real(dbl), intent(OUT) :: pot(nts_act)
       integer(i4b) :: its  
        do its=1,nts_act
          pot(its)=dot_product(c,matmul(vts(its,:,:),c))
        enddo 
       return
      end subroutine
!
!------------------------------------------------------------------------
!> Calculates complex "potentials" on BEM surface from CIS coefficients 
!------------------------------------------------------------------------
      subroutine do_cpot_from_coeff(c,cpot,vts)
       complex(cmp), intent(IN) :: c(n_ci)
       complex(cmp), intent(OUT) :: cpot(n_ci)
       real(dbl), intent(IN) :: vts(n_ci,n_ci)
       integer(i4b) :: k  
        do k=1,n_ci   
          if(Fprop(1:3).eq."chr") cpot=exp(ui*e_ci(k))*matmul(vts,c)
          if(Fprop(1:3).eq."osc") cpot=exp(ui*e_ci(k))*matmul(vts,c)
        enddo 
       return
      end subroutine
!
!------------------------------------------------------------------------
!> Calculates the field at rf produced by a dipole d located at rd
!------------------------------------------------------------------------
      subroutine do_field_from_dip(d,rd,f,rf)
       real(dbl), intent(IN) :: d(3),rd(3),rf(3)
       real(dbl), intent(OUT) :: f(3)        
       real(dbl):: r(3),m
        r=rf-rd
        m=1/mdl(r)
        r=r*m
        f=three*dot_product(d,r)*r-d
        f=f*m*m*m
       return
      end subroutine
!
!------------------------------------------------------------------------
!> Calculates potential on BEM surface from CIS coefficients (ons version)
!------------------------------------------------------------------------
      subroutine do_pot_from_dip(dip,pot)
       real(dbl), intent(IN) :: dip(3)
       real(dbl), intent(OUT) :: pot(nts_act)
       real(dbl):: diff(3)  
       real(dbl):: dist
       integer(i4b) :: its  
        pot(:)=zero
        do its=1,nts_act
          diff(1)=-(mol_cc(1)-cts_act(its)%x)
          diff(2)=-(mol_cc(2)-cts_act(its)%y)
          diff(3)=-(mol_cc(3)-cts_act(its)%z)
          dist=sqrt(dot_product(diff,diff))
          pot(its)=pot(its)+dot_product(diff,dip)/(dist**3)
        enddo
       return
      end subroutine
!
!------------------------------------------------------------------------
!> Computes (transition) BEM-potentials from dipoles
!------------------------------------------------------------------------
      subroutine do_vts_from_dip
       integer(4) :: i,j,its
       real(dbl) :: diff(3),dist,vts_dip
       do its=1,nts_act
        diff(1)=(mol_cc(1)-cts_act(its)%x)
        diff(2)=(mol_cc(2)-cts_act(its)%y)
        diff(3)=(mol_cc(3)-cts_act(its)%z)
        dist=sqrt(dot_product(diff,diff))
        do i=1,n_ci
         do j=i,n_ci
          vts_dip=-dot_product(mut(:,j,i),diff)/dist**3
          if(its.eq.nts_act) write (6,'(2i6,3f8.3,2e13.5)') i,j, &
                          cts_act(its)%x,cts_act(its)%y, &
                          cts_act(its)%z,vts_dip,vts(its,i,j)
          vts(its,j,i)=vts_dip
          vts(its,i,j)=vts_dip
         enddo
        enddo
       enddo
       return
       end subroutine
!
      end module
