      Module MathTools       
      use global_tdplas    
      use constants        
      use pedra_friends
      use readio_medium       
#ifdef OMP
      use omp_lib
#endif

#ifdef MPI
#ifndef SCALI
      use mpi
#endif
#endif

      implicit none

      save
      private
      public diag_mat,inv,do_pot_from_field,do_field_from_charges,    &
             do_dip_from_charges,do_dip_from_coeff,do_pot_from_coeff, &
             do_pot_from_dip,do_vts_from_dip,mdl,vprod,               &
             do_cpot_from_coeff,do_field_from_dip,mat_mult,cmat_mult                      
      contains


      subroutine diag_mat(M,E,Md)     
!------------------------------------------------------------------------
! @brief Diagonalizes the matrix M using dsyevd, E=eigenvalues, M=eigenvectors 
!
! @date Created: S. Pipolo
! Modified:
!------------------------------------------------------------------------

       integer(i4b), intent(in) :: Md
       real(dbl), intent(inout) :: M(Md)
       real(dbl), intent(out) :: E(Md)
       ! Local variables
       integer(i4b) :: info,lwork,liwork
       integer(i4b), allocatable :: iwork(:)
       real(dbl),allocatable :: work(:)
       character jobz,uplo

       jobz = 'V'
       uplo = 'U'
       lwork = 1+6*Md+2*Md*Md
       liwork = 3+5*Md
       allocate(work(lwork))
       allocate(iwork(liwork))
       iwork=0
       work=zero
       call dsyevd (jobz,uplo,Md,M,Md,E,work,lwork,iwork,liwork,info)
       deallocate(work,iwork)

       return

      end subroutine


      function mdl(v) result(m)
!------------------------------------------------------------------------
! @brief Compute the modulus of a vector 
!
! @date Created: S. Pipolo
! Modified:
!------------------------------------------------------------------------

        real(dbl), dimension(:), intent(in) :: v
        real(dbl) :: m  
        integer(i4b) :: i

        m=zero

        do i=1,size(v)
          m=m+v(i)*v(i)
        enddo

        m=sqrt(m)

      end function mdl


      function vprod(a,b) result(v)
!------------------------------------------------------------------------
! @brief Compute the vector product between two vectors 
!
! @date Created: S. Pipolo
! Modified:
!------------------------------------------------------------------------

        real(dbl), dimension(3), intent(in)  :: a  
        real(dbl), dimension(3), intent(in)  :: b  
        real(dbl), dimension(3) :: v 

        v(1)=a(2)*b(3)-a(3)*b(2)
        v(2)=a(3)*b(1)-a(1)*b(3)
        v(3)=a(1)*b(2)-a(2)*b(1)

      end function vprod


      function inv(A) result(Ainv)
!------------------------------------------------------------------------
! @brief Invert matrix A using LU factorization 
!
! @date Created: S. Pipolo
! Modified:
!------------------------------------------------------------------------

        real(dbl), dimension(:,:), intent(in) :: A
        real(dbl), dimension(size(A,1),size(A,2)) :: Ainv
      
        real(dbl), dimension(size(A,1)) :: work  ! work array for LAPACK
        integer(i4b), dimension(size(A,1)) :: ipiv   ! pivot indices
        integer(i4b) :: n, info
      
        ! External procedures defined in LAPACK
        external DGETRF
        external DGETRI
      
        ! Store A in Ainv to prevent it from being overwritten by LAPACK
        Ainv = A
        n = size(A,1)
      
        ! DGETRF computes an LU factorization of a general M-by-N matrix A
        ! using partial pivoting with row interchanges.
        call DGETRF(n, n, Ainv, n, ipiv, info)
      
        if (info /= 0) then
           stop 'Matrix is numerically singular!'
        end if
      
        ! DGETRI computes the inverse of a matrix using the LU factorization
        ! computed by DGETRF.
        call DGETRI(n, Ainv, n, ipiv, work, n, info)
      
        if (info /= 0) then
           stop 'Matrix inversion failed!'
        end if

      end function inv


      subroutine do_pot_from_field(fld,pot)
!------------------------------------------------------------------------
! @brief Compute the potential on the BEM surface generated by a field
! (fld) 
!
! @date Created: S. Pipolo
! Modified: 
!------------------------------------------------------------------------

       real(dbl), intent(in):: fld(3) 
       real(dbl), intent(out):: pot(nts_act) 
       integer(i4b) :: its  

       ! Field
       pot(:)=zero
#ifdef OMP
!$OMP PARALLEL REDUCTION(+:pot)
!$OMP DO 
#endif
        do its=1,nts_act
          pot(its)=pot(its)-fld(1)*cts_act(its)%x           
          pot(its)=pot(its)-fld(2)*cts_act(its)%y          
          pot(its)=pot(its)-fld(3)*cts_act(its)%z         
        enddo
#ifdef OMP
!$OMP enddo
!$OMP END PARALLEL
#endif

        return

      end subroutine


      subroutine do_field_from_charges(q,f)
!------------------------------------------------------------------------
! @brief Compute field f on molecule's center of charge from BEM charges
! q 
!
! @date Created: S. Pipolo
! Modified:
!------------------------------------------------------------------------

       real(dbl),intent(inout):: f(3)  
       real(dbl),intent(in):: q(nts_act)  
       real(dbl):: diff(3)  
       real(dbl):: dist
       integer(i4b) :: its  

       f(:)=zero
#ifdef OMP
!$OMP PARALLEL REDUCTION(+:f)
!$OMP DO 
#endif
       do its=1,nts_act
          diff(1)=(mol_cc(1)-cts_act(its)%x)
          diff(2)=(mol_cc(2)-cts_act(its)%y)
          diff(3)=(mol_cc(3)-cts_act(its)%z)
          dist=sqrt(dot_product(diff,diff))
          f(:)=f(:)+q(its)*diff(:)/(dist**3)
       enddo
#ifdef OMP
!$OMP enddo
!$OMP END PARALLEL
#endif

       return

      end subroutine


      subroutine do_dip_from_charges(q,mu,qtot)
!------------------------------------------------------------------------
! @brief Compute (update previous value) the dipole (mu) of BEM charges
! (q) 
!
! @date Created: S. Pipolo
! Modified:
!------------------------------------------------------------------------

       real(dbl),intent(inout):: mu(3)  
       real(dbl),intent(in):: q(nts_act)  
       real(dbl),intent(out):: qtot  
       integer(i4b) :: its  

       qtot=zero
#ifdef OMP
!$OMP PARALLEL REDUCTION(+:mu,qtot)
!$OMP DO 
#endif
       do its=1,nts_act
         mu(1)=mu(1)+q(its)*(cts_act(its)%x)
         mu(2)=mu(2)+q(its)*(cts_act(its)%y)
         mu(3)=mu(3)+q(its)*(cts_act(its)%z)
         qtot=qtot+q(its)
       enddo
#ifdef OMP
!$OMP enddo
!$OMP END PARALLEL
#endif

       return

      end subroutine


      subroutine do_dip_from_coeff(c,dip,nc)
!------------------------------------------------------------------------
! @brief Compute dipole from CIS coefficients 
!
! @date Created: S. Pipolo
! Modified: E. Coccia 5/7/18
!------------------------------------------------------------------------

       integer(i4b), intent(IN)  :: nc  
       complex(cmp), intent(IN)  :: c(nc)
       real(dbl),    intent(OUT) :: dip(3)
       integer(i4b)              :: its,j,k  
       complex(cmp)              :: ctmp(nc) 

#ifndef OMP
       dip(1)=dot_product(c,matmul(mut(1,:,:),c))
       dip(2)=dot_product(c,matmul(mut(2,:,:),c))
       dip(3)=dot_product(c,matmul(mut(3,:,:),c))
#endif
#ifdef OMP
      if (Fopt(1:3).eq.'omp') then
         ctmp=0.d0
!$OMP PARALLEL REDUCTION(+:ctmp) 
!$OMP DO
         do k=1,nc
            do j=1,nc
               ctmp(k)=ctmp(k)+ mut(1,k,j)*c(j)
            enddo
         enddo
!$OMP END PARALLEL
         dip(1)=dot_product(c,ctmp)

         ctmp=0.d0
!$OMP PARALLEL REDUCTION(+:ctmp) 
!$OMP DO
         do k=1,nc
            do j=1,nc
               ctmp(k)=ctmp(k)+ mut(2,k,j)*c(j)
            enddo
         enddo
!$OMP END PARALLEL
         dip(2)=dot_product(c,ctmp)

         ctmp=0.d0
!$OMP PARALLEL REDUCTION(+:ctmp) 
!$OMP DO
         do k=1,nc
            do j=1,nc
               ctmp(k)=ctmp(k)+ mut(3,k,j)*c(j)
            enddo
         enddo
!$OMP END PARALLEL
         dip(3)=dot_product(c,ctmp)
      else
         dip(1)=dot_product(c,matmul(mut(1,:,:),c))
         dip(2)=dot_product(c,matmul(mut(2,:,:),c))
         dip(3)=dot_product(c,matmul(mut(3,:,:),c))
      endif 
#endif

       return

      end subroutine


      subroutine do_pot_from_coeff(c,pot)
!------------------------------------------------------------------------
! @brief Compute potential on BEM surface from CIS coefficientes 
!
! @date Created: S. Pipolo
! Modified: E. Coccia 5/7/18
!------------------------------------------------------------------------

       complex(cmp), intent(IN)  :: c(n_ci)
       real(dbl),    intent(OUT) :: pot(nts_act)
       integer(i4b)              :: its,k,j  
       real(dbl)                 :: ctmp(nts_act,n_ci)


#ifndef OMP
       do its=1,nts_act
          pot(its)=dot_product(c,matmul(vts(its,:,:),c))
       enddo
#endif

#ifdef OMP
       if (Fopt(1:3).eq.'omp') then
          ctmp=0.d0
!$OMP PARALLEL reduction (+:ctmp)
!$OMP DO 
          do k=1,n_ci
             do j=1,n_ci
                do its=1,nts_act
                   ctmp(its,k)=ctmp(its,k)+ vts(its,k,j)*c(j)
                enddo
             enddo
          enddo
!$OMP END PARALLEL
!$OMP PARALLEL
!$OMP DO
         do its=1,nts_act
            pot(its)=dot_product(c,ctmp(its,:))
         enddo
!$OMP END PARALLEL
       else
!$OMP PARALLEL
!$OMP DO
         do its=1,nts_act
            pot(its)=dot_product(c,matmul(vts(its,:,:),c))
         enddo 
!$OMP END PARALLEL
       endif
#endif

       return

      end subroutine


      subroutine do_cpot_from_coeff(c,cpot,vts)
!------------------------------------------------------------------------
! @brief Compute complex "potentials" on BEM surface from CIS
! coefficientes 
!
! @date Created: S. Pipolo
! Modified: E. Coccia 5/7/18
!------------------------------------------------------------------------

       complex(cmp), intent(IN)  :: c(n_ci)
       complex(cmp), intent(OUT) :: cpot(n_ci)
       real(dbl),    intent(IN)  :: vts(n_ci,n_ci)
       integer(i4b)              :: i,j,k  
       complex(cmp)              :: ctmp(n_ci)

#ifndef OMP
       do k=1,n_ci   
          if(Fprop(1:3).eq."chr") cpot=exp(ui*e_ci(k))*matmul(vts,c)
          if(Fprop(1:3).eq."osc") cpot=exp(ui*e_ci(k))*matmul(vts,c)
       enddo 
#endif
#ifdef OMP
       if (Fopt(1:3).eq.'omp') then
          if (Fprop(1:3).eq."chr".or.Fprop(1:3).eq."osc") then
             ctmp=0.d0
!$OMP PARALLEL REDUCTION(+:ctmp) 
!$OMP DO
             do k=1,n_ci
                do j=1,n_ci
                   ctmp(k)=ctmp(k)+ vts(k,j)*c(j)
                enddo
             enddo
!$OMP END PARALLEL
             do k=1,n_ci
                cpot=exp(ui*e_ci(k))*ctmp 
             enddo
          endif
       else
          do k=1,n_ci
             if(Fprop(1:3).eq."chr") cpot=exp(ui*e_ci(k))*matmul(vts,c)
             if(Fprop(1:3).eq."osc") cpot=exp(ui*e_ci(k))*matmul(vts,c)
          enddo
       endif 
#endif

       return

      end subroutine


      subroutine do_field_from_dip(d,rd,f,rf)
!------------------------------------------------------------------------
! @brief Compute the field at rf produced by a dipole d located at rd 
!
! @date Created: S. Pipolo
! Modified:
!------------------------------------------------------------------------

       real(dbl), intent(IN) :: d(3),rd(3),rf(3)
       real(dbl), intent(OUT) :: f(3)        
       real(dbl):: r(3),m

       r=rf-rd
       m=1/mdl(r)
       r=r*m
       f=three*dot_product(d,r)*r-d
       f=f*m*m*m

       return

      end subroutine


      subroutine do_pot_from_dip(dip,pot)
!------------------------------------------------------------------------
! @brief Compute potential on BEM surface from CIS coefficients (ons) 
!
! @date Created: S. Pipolo
! Modified:
!------------------------------------------------------------------------

       real(dbl), intent(IN) :: dip(3)
       real(dbl), intent(OUT) :: pot(nts_act)
       real(dbl):: diff(3)  
       real(dbl):: dist
       integer(i4b) :: its  

       pot(:)=zero
#ifdef OMP
!$OMP PARALLEL REDUCTION(+:pot)
!$OMP DO
#endif
       do its=1,nts_act
          diff(1)=-(mol_cc(1)-cts_act(its)%x)
          diff(2)=-(mol_cc(2)-cts_act(its)%y)
          diff(3)=-(mol_cc(3)-cts_act(its)%z)
          dist=sqrt(dot_product(diff,diff))
          pot(its)=pot(its)+dot_product(diff,dip)/(dist**3)
       enddo
#ifdef OMP
!$OMP enddo
!$OMP END PARALLEL
#endif

       return

      end subroutine


      subroutine do_vts_from_dip
!------------------------------------------------------------------------
! @brief Compute (transition) BEM potentials from dipoles 
!
! @date Created: S. Pipolo
! Modified:
!------------------------------------------------------------------------

       integer(4) :: i,j,its
       real(dbl)  :: diff(3),dist,vts_dip

       do its=1,nts_act
          diff(1)=(mol_cc(1)-cts_act(its)%x)
          diff(2)=(mol_cc(2)-cts_act(its)%y)
          diff(3)=(mol_cc(3)-cts_act(its)%z)
          dist=sqrt(dot_product(diff,diff))
          do i=1,n_ci
             do j=i,n_ci
                vts_dip=-dot_product(mut(:,j,i),diff)/dist**3
                if(its.eq.nts_act) write (6,'(2i6,3f8.3,2e13.5)') i,j, &
                          cts_act(its)%x,cts_act(its)%y, &
                          cts_act(its)%z,vts_dip,vts(its,i,j)
                vts(its,j,i)=vts_dip
                vts(its,i,j)=vts_dip
             enddo
          enddo
       enddo

       return

      end subroutine


      function mat_mult(a,b)
!------------------------------------------------------------------------
! @brief Optimized matrix/vector multiplication for tesserae-based
! arrays 
!
! @date Created: E. Coccia 5/7/18 
! Modified:
!------------------------------------------------------------------------

       implicit none

       real(dbl),    intent(in)    :: a(nts_act,nts_act),b(nts_act)
       real(dbl)                   :: mat_mult(nts_act),tmp(nts_act)

       integer(i4b)                :: i,j

#ifndef OMP
       mat_mult=matmul(a,b)
#endif       
#ifdef OMP

       if (Fopt_chr(1:3).eq.'omp') then
          tmp=0.d0
!$OMP PARALLEL reduction (+:tmp)
!$OMP DO
          do j=1,nts_act
             do i=1,nts_act
                tmp(j) = tmp(j) + a(j,i)*b(i)
             enddo
          enddo
!$OMP END PARALLEL
          mat_mult=tmp
       else
          mat_mult=matmul(a,b)
       endif
#endif       

       return

      end function mat_mult


      function cmat_mult(a,b)
!------------------------------------------------------------------------
! @brief Optimized matrix/vector multiplication for tesserae-based
! (real and complex) arrays 
!
! @date Created: E. Coccia 9/7/18 
! Modified:
!------------------------------------------------------------------------

       implicit none

       real(dbl),    intent(in)    :: a(n_ci,n_ci)
       complex(cmp), intent(in)    :: b(n_ci)
       complex(cmp)                :: cmat_mult(n_ci),tmp(n_ci)

       integer(i4b)                :: i,j

#ifndef OMP
       cmat_mult=matmul(a,b)
#endif       
#ifdef OMP
       if (Fopt(1:3).eq.'omp') then
          tmp=0.d0
!$OMP PARALLEL reduction (+:tmp)
!$OMP DO
          do j=1,n_ci
             do i=1,n_ci
                tmp(j) = tmp(j) + a(j,i)*b(i)
             enddo
          enddo
!$OMP END PARALLEL
          cmat_mult=tmp
       else
          cmat_mult=matmul(a,b)
       endif
#endif       

       return

      end function cmat_mult



      end module
